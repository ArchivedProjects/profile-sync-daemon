#!/bin/bash
# By graysky <graysky AT archlinux DOT us>
# Inspired by some code originally written by Colin Verot

# nothing to do if there is no conf file
if [[ ! -f /etc/psd.conf ]]; then
	echo "Cannot find /etc/psd.conf so bailing.  Reinstall package to use profile-sync-daemon."
	exit 1
else
	. /etc/psd.conf
fi

# nothing to do if there are no users
if [[ -z "$USERS" ]]; then
	echo "Must define at least one user in /etc/psd.conf"
	exit 1
fi

BROWSERS=${BROWSERS:-"chromium conkeror.mozdev.org firefox google-chrome heftig-aurora midori opera opera-next qupzilla"} # all supported browsers

[[ -z "$VOLATILE" ]] && VOLATILE="/tmp"

# make it overrideable from the commandline / config
DAEMON_FILE=${DAEMON_FILE:-"/run/psd"}

root_check() {
	# we call this to ensure that only the root user is calling the function
	# why care? both the sync and unsync functions require root access to /run/psd (the pseudo pid file)
	# running as unprivileged user will fuck up the sync process resulting in unhappy users

	if [[ $EUID -ne 0 ]]; then
		echo "This function must be called as root!" 1>&2
		exit 1
	fi
}

set_which() {
	local user=$1
	local browser=$2
	homedir="$(getent passwd $user | cut -d: -f6)"
	group="$(stat -c %G $homedir)"

	# reset global variables
	BACKUP=
	DIR=

	# skip homeless users
	if [[ -z $homedir ]]; then
		return
	fi

	case "$browser" in
		chromium|google-chrome|midori)
			BACKUP="$homedir/.config/$browser-backup"
			DIR="$homedir/.config/$browser"
			ENAME="$browser"
			;;
		firefox)
			BACKUP="$homedir/.mozilla/firefox-backup"
			DIR="$homedir/.mozilla/firefox"
			ENAME="$browser"
			;;
		heftig-aurora)
			# https://bbs.archlinux.org/viewtopic.php?id=117157
			BACKUP="$homedir/.mozilla/aurora-backup"
			DIR="$homedir/.mozilla/aurora"
			ENAME="aurora"
			;;
		opera|opera-next|qupzilla)
			BACKUP="$homedir/.$browser-backup"
			DIR="$homedir/.$browser"
			ENAME="$browser"
			;;
		conkeror.mozdev.org)
			BACKUP="$homedir/.$browser-backup"
			DIR="$homedir/.$browser"
			ENAME="xulrunner"
			;;
		*)
			# skip invalid browser entries
			return
	esac
}

sync() {
	root_check

	# used to check if psd is active
	touch "$DAEMON_FILE"

	# sync profiles to tmpfs and back again
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"

			# make tmpfs container
			if [[ -d $DIR ]]; then
				[[ -r "$VOLATILE/$user-$browser" ]] || install -dm755 --owner=$user --group=$group "$VOLATILE/$user-$browser"

				# backup target and link to tmpfs container
				if [[ $(readlink "$DIR") != "$VOLATILE/$user-$browser" ]]; then
					mv "$DIR" "$BACKUP"
					ln -s "$VOLATILE/$user-$browser" "$DIR"
					chown -h $user:$group "$DIR"
				fi

				# sync the tmpfs targets to the disc
				if [[ -e $DIR/.flagged ]]; then
					rsync -aog --delete-after --delay-updates --exclude .flagged "$DIR/" "$BACKUP/"
				else
					rsync -aog --delay-updates "$BACKUP/" "$DIR/"
					touch "$DIR/.flagged"
				fi
			fi
		done
	done
}

debug() {
	echo -en "\E[31m::DEBUG MODE::"
	tput sgr0 # reset colors to normal
	echo
	echo
	echo "Your settings in /etc/psd.conf will make profile-sync-daemon manage the following browers/user combos when invoked:"
	echo
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			if [[ -d "$DIR" ]]; then
				echo "owner/group:       $user:$group"
				echo "browser to manage: $browser"
				echo "homedir:           $homedir"
				echo "backup target:     $BACKUP"
				echo
			fi
		done
	done
}

check() {
	root_check

	# crash recovery
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			[[ -h $DIR ]] && unlink "$DIR"
			[[ -d $BACKUP ]] && mv "$BACKUP" "$DIR"
		done
	done
}

unsync() {
	root_check

	# remove daemon state indicator file
	rm -f "$DAEMON_FILE"

	# restore virgin state of profiles on physical discs
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			
			# kill browser if running to safely sync back to disk thus safeguarding browser profile
			x=1
			while [[ $x -le 5 ]]; do
				if [[ -n $(pgrep -u $user $ENAME) ]]; then
					pkill -SIGTERM -u $user $ENAME
					sleep 1s
				else
					/bin/true
				fi
				x=$(( $x + 1 ))
			done

			### Do we need a secondary, more powerful method of killing if the first fails?

			# check if user has browser profile
			if [[ -h "$DIR" ]]; then
				unlink "$DIR"
				# this assumes that the backup is always updated so be sure to invoke a sync
				# before an unsync
				#
				# restore original dirtree
				[[ -d "$BACKUP" ]] && mv "$BACKUP" "$DIR"
				[[ -d "$VOLATILE/$user-$browser" ]] && rm -rf "$VOLATILE/$user-$browser"
			fi
		done
	done
}

case "$1" in
	debug)
		debug
		;;
	sync)
		[[ ! -f $DAEMON_FILE ]] && check
		sync
		;;
	resync)
		[[ -f $DAEMON_FILE ]] && sync
		;;
	unsync)
		# make sure the daemon is running
		[[ -f $DAEMON_FILE ]] && sync && unsync
		;;
	*) 
		echo -en "\E[31musage: "
		tput sgr0 # reset colors to normal
		echo "$0 {sync|unsync|debug}"
		echo "  sync) Force a manual sync."
		echo "unsync) Force a manual unsync."
		echo " debug) Parse config file to make sure vars are correctly defined."
		;;
esac
exit 0
